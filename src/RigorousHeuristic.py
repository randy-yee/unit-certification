read("src/VectorMethods.py");
read("src/LogarithmLattice.py");
read("src/CompactRepresentation.py");
read("src/Neighbours.py")
read("src/bounds.gp")
read("src/PmaxNormal.py");
update_eta_set_log_write(~pkvec, G,p,k, cpct_reps, expmat, loglat, torsion_coeffs = [])={

    my(eta_k, eta_i, cebotarev_ideal, exponent_tracker=[], exponent_i, temporary_cpctreps);
    time1 = getabstime();
    [cebotarev_ideal,temporary_cpctreps] = get_search_ideal_cpct_write(~pkvec, G,p, k, cpct_reps, expmat, torsion_coeffs);
    time2 = getabstime();
    for(i=k+1, 0,
        exponent_i = get_new_eta_cpct(G, p , k, i, cebotarev_ideal, temporary_cpctreps, expmat,torsion_coeffs);
        exponent_tracker = concat(exponent_tracker, exponent_i);
    );

    time3 = getabstime();
    \\print(p, "cpct rep time: ", time3-time2, "  find ideal time: ", time2- time1);

    return(exponent_tracker);
}
get_search_ideal_cpct_write(~pkvec, G,p, k, cpctreps, expmat, torsion_coeffs=[])={
    my(check_poly,
      field_deg = length(G.zk),               \\ degree of the number field
      prime_q,                                \\ holder for the pohst prime
      prime_decomposition,                    \\ holds ideal factorization of the prime p
      factor_candidate,                       \\ variable for holding a prime ideal
      res_field,                              \\ holds the residue field generated by factor_candidate
      embedded_eta,                           \\ used to check irreducibility mod the factor_candidate
      expvec,
      ideal_candidate_found = 0,              \\ flag to indicate an ideal has been found
      lowbound =1,                            \\ the lower bound for get_pohst_prime
      denom_lcm = lcm_denominators(cpctreps),
      prime_ctr = 1
    );

    while(!ideal_candidate_found,
        prime_q = get_pohst_prime2(G.disc, p, lowbound, denom_lcm);
        prime_decomposition = idealprimedec(G,prime_q);                         \\ Decompose prime_q as ideals in G (as vector of prid structures)

        if(DEBUG_IDEAL_SEARCH,print(" - Found Pohst prime q: ", prime_q, "\n - Number of Factors of q: ", length(prime_decomposition)););
        \\ loop over all the prime ideals, look for one where the polynomial t^p - pohst_eta = 0 is irreducible
        for(i = 1, length(prime_decomposition),

            factor_candidate = prime_decomposition[i];                          \\ holds the ith ideal of the decomposition, call it P

            res_field = nfmodprinit(G,factor_candidate);                        \\ converts prime ideal P into residue field OK/P

            \\#ensure prime_q has gcd 1 with the cpctrep denominators
            GP_ASSERT_TRUE(gcd(denom_lcm, prime_q) == 1);

            \\ handles the torsion case
            if(k == 0,
                embedded_eta = nfmodpr(G, nfalgtobasis(G,nfrootsof1(G)[2]),res_field);
            ,\\else
                expvec = expmat[,k];
                embedded_eta = cpct_modp_from_factors(G, cpctreps, expvec, res_field);

                if(length(torsion_coeffs) != 0,
                    embedded_eta *= nfmodpr(G, nfalgtobasis(G,nfrootsof1(G)[2]),res_field)^torsion_coeffs[k];
                );
            );

            \\ irreducibility check of Pohst/Arenz
            if (embedded_eta^( (factor_candidate[1]^factor_candidate.f-1)/p) != 1,

                if((prime_q-1)/p > pkvec[2],
                    print((prime_q-1)/p, "  ", pkvec[2], "  ", pkvec[1]);
                    pkvec[1] = p;
                    pkvec[2] = (prime_q-1)/p;
                );
                \\write(heuristic_outfile, p, " , ", prime_q);

                return([factor_candidate,cpctreps]);                            \\ Should always exit the function here unless the input is invalid
            );
            prime_ctr+=1;
        );
        lowbound = prime_q++;
    );
    print( "ERROR: Did not find any prime ideal with the irreducibility property.");
    return(0);
}; \\ end function get_search ideal


\\ INPUTS:
\\ - L is the logarithm lattice (see output of process_complex_loglattice)
\\ - unitvector_cpct is the corresponding compact representations
\\ - B is the index bound
\\ - eps is precision level for comparisons
heuristic_test_pmax(G,L,unitvector_cpct, B, eps, update_bound = 1, OUTFILE1 = "log_pohst_output")={
    print("Testing PMAX heuristic ", B);
    heuristic_outfile = concat(concat("data/pmax-heuristic-",G.r1), G.r2);
    write(heuristic_outfile, "Discriminant: ", G.disc);
    GP_ASSERT_TRUE(update_bound == 1 || update_bound == 0);

    my(new_units = L, index_holder = 1, index_bound = B, solution, solutionflag = 0, p = 2);
    my(eta_exp_mat, compact_lcm, test_eta_k, updatevec);
    my( torsion_coeffs, [torsion, torsiongen] = nfrootsof1(G) );

    \\# set the N parameter for heuristic index divisor test
    my(param_N = max(10, 2*(G.r1+G.r2)));

    betavec = unitvector_cpct;
    compact_lcm = lcm_denominators(unitvector_cpct);
    p = nextprime(B); p_ctr = 0;
    max_k = 0;  max_p= 1;
    pkvec = [max_p, max_k];
    while(p_ctr <= 1000,

        \\# include torsion in pari check when p is not coprime w/ size of torsion group
        if(torsion %p == 0,
            betavec = concat(betavec, [[ List( [nfalgtobasis(G, torsiongen)] ), [1]  ]] );
        );

        \\#TO SKIP THE FAST PRIME CHECK, replace the if argument with a 1
        if(1 ,
            eta_exp_mat = matid(length(new_units));

            torsion_coeffs = [];
            if(gcd(p,torsion)!=1,
                \\ update eta set using the torsion unit, store the coeffs in a vector
                torsion_coeffs = update_eta_set_log_write(~pkvec, G,p,0,unitvector_cpct, eta_exp_mat, new_units);
            );

            \\# each time a new prime is considered, reset k to 1
            k = 1;

            \\# flag indicates if a solution has been found
            solutionflag = 1;

            \\# hold either 0 or a found solution
            solution = 0;

            while(solutionflag == 1,
                \\\# step 1 of Algorithm 8, the pth root test
                test_eta_k = new_units*eta_exp_mat[,k];
                test_eta_k = test_eta_k/p;

                \\solutionflag = check_in_unitlattice(G, test_eta_k~, eps);
                solutionflag = 0;

                if(solutionflag ==1,
                    print("this should never occur");
                , \\else
                    \\# no sol is found

                    if(k == length(L),solutionflag = 0; break;);

                    updatevec = update_eta_set_log_write(~pkvec,G,p,k,unitvector_cpct, eta_exp_mat, new_units, torsion_coeffs);
                    \\eta_exp_mat = update_expmat(eta_exp_mat, updatevec, k , p );

                    \\torsion_coeffs = torsion_update(~torsion_coeffs, ~updatevec, k);

                    \\# Update k and reset solutionflag to 1
                    k+=1;
                    solutionflag = 1;
                );
            );

        , \\else:
            if(p%100000 ==1, print("LPohst: pari_check succeeds for, ",p, ". Now checking p = ", nextprime(p+1)));
        );
        if(torsion %p == 0,
            betavec = unitvector_cpct;
            compact_lcm = lcm_denominators(unitvector_cpct);                    \\ used as the 'bad' input to pari_prime_check, ignores non-coprime primes during the equation finding step
        );
        p_ctr +=1;
        p = nextprime(p+1);
    );
    write(heuristic_outfile, pkvec[1] , " , " , pkvec[2] );
    return(new_units);

}
