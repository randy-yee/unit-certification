\\ Neighbours module

read("src/VectorMethods.py");
read("src/LogarithmLattice.py");

DEBUG_REDDIV = 0;
DEBUG_EXPAND = 0;
DEBUG_MINIMALSET = 0;
DEBUG_COLLECT = 0;
/*
FUNCTIONS:
- check_duplicate_minset
- findbeta

- cubescan
-- get_scaled_vector_cubescan
- cubescan_equal
- cubescan_unequal

- is_minimum
- is_minimum_alternate
- is_neighbour

- expand_minset
- compress_minset
- check_minset_1
- compute_one_neighbours
-- include_new_minset
- NEIGHBORS

- COLLECT
-- compute_collect_boundary
-- increase_collection

- COLLECT_BABYSTOCK
- truncatereal
- TARGET

*/


/*
NOTES/COMMENTS
- Care needs to be taken when dealing with the log vector. Fontein Jacobson describe the log vector as the log of the abs of each embedding.
  Buchmann and other papers often use the norm rather than abs for complex valuations, so an adjustment needs to be made.
- minimal sets will be taken to be a pari consisting of a set of elements along with a (real) boundary vector.
*/

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
\\ INPUT:
\\ - a set of minimal sets, setS (recall minimal sets are pairs of 1) a set of elements, 2) a (real) boundary vector
\\ - eltS is a Set of elements of a minimal set (recall that in pari Sets are ordered)
\\ OUTPUT:
\\ - 0 or 1 depending on whether eltS is already in setS
check_duplicate_minset(setS, eltS)={
		for(i=1, length(setS),
				if(setS[i][1] == eltS, return(1););
		);
		return(0);
}

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
\\ Subroutine of the Alg. 2.4 of BJP (Expansion), see: expand_minset
\\ checks whether each element of setS satisfies the condition that
\\ its ith valuation is smaller than C_i, for i != j, where j is an integer value specified by the variable 'axis'
\\ Part of Alg 2.5, takes an output of qfminim (set of elements) and checks that the elements are inside the box defined by C

\\ INPUT:
\\ - G is a number field
\\ - setS is a matrix whose columns are number field elements
\\ - Cvector is a positive real vector
\\ - axis is an integer, which indicates an coordinate for which the comparison can be ignored.
\\ OUTPUT
\\ - Returns 0 if the condition is false, returns beta if an element satisfying the conditions are found.
findbeta(G,setS, Cvector, axis)={
		for(i=1, length(setS),
				if(vec_less_than(  valuationvec( G, nfbasistoalg(G,setS[i]) ),Cvector, axis  ),
				 		return(setS[i]);
				);
		);
		return(0);
}


\\ subalgorithm for cubescan which scales a basis element embedded into R^n by the vector C
get_scaled_vector_cubescan(G, ideal_column, c_vector)={
    my(boundary_j,alpha_embedding,alpha_complex_split,c_split);
    alpha_embedding = nfeltembed(G, ideal_column);
    boundary_j = pointwise_vector_div(alpha_embedding[1..G.r1], c_vector[1..G.r1]);

    alpha_complex_split = alpha_embedding[G.r1+1..(G.r1+G.r2)];
    alpha_complex_split = concat(real(alpha_complex_split), imag(alpha_complex_split));
    c_split = sqrt(c_vector[(G.r1+1)..(G.r1+G.r2)]);
    c_split = concat(c_split, c_split);
    alpha_complex_split = pointwise_vector_div(alpha_complex_split, c_split);

    boundary_j = concat(boundary_j, alpha_complex_split);
    return(boundary_j);
}

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
\\ this is Alg 2.5 of BJP (Practical Lagrange Algorithm), subroutine of expand_minset using pohst-fincke
\\ Note: Use cubescan_equal and cubescan_unequal below rather than this function directly.
\\ Input:
\\ - idealmat: coefficient matrix representing an ideal basis
\\ - cvec    : vector of positive reals, defines the boundaries of the search cube, length r1+r2
\\ - G       : number field (generated by nfinit)
\\ - The flag onlyone should be set to 1 in cases where only need a single element in the cube is needed.
\\ OUTPUT:
\\ - set of elements in the ideal that sit inside cvec cube
\\ - returned as a matrix whose columns are the element coeffs wrt integral basis.
cubescan(idealmat, cvec, G, onlyone = 0)={
		my(
            Z_set = [],
			alpha_embedding, alpha_stub, c_stub,
			boundary_j,
			fincke_pohst_elts,
			beta_coeff,
			within_box,
			beta_embedding,
            b_matrix =Mat();
		);

		for(j = 1, matsize(idealmat)[2],
            boundary_j = get_scaled_vector_cubescan(G, idealmat[,j], cvec);
			b_matrix = matconcat([b_matrix, boundary_j]);
		);
		if(onlyone == 0,
			fincke_pohst_elts = qfminim(b_matrix~*b_matrix, length(cvec), , 2)[3];
		,	\\else
			fincke_pohst_elts = qfminim(b_matrix~*b_matrix, length(cvec), 1, 2)[3];
		);

        for(i=1, length(cvec),
            if(i > G.r1, cvec[i]= sqrt(cvec[i]));
        );

		for (k =1, length(fincke_pohst_elts),
            beta_coeff = (idealmat*fincke_pohst_elts[,k]);							\\ not according to algorithm desc, yields beta as coeff vector wrt integral basis

            /*
            beta_embedding = valuationvec(G,beta_coeff);	                        \\ note the squares on the valuations here
            within_box = 1;
			for(j =1, length(beta_embedding),								    \\ for loop checks if beta inside the cvec box
					if(beta_embedding[j] > cvec[j],
					 		within_box = 0;)
			);
            */

            beta_embedding = abs(G[5][1]*beta_coeff);
            within_box = 1;
            for(j =1, length(beta_embedding),								    \\ for loop checks if beta inside the cvec box
					if(beta_embedding[j] > cvec[j],
					 		within_box = 0;)
			);

			if(within_box == 1,
                    Z_set = concat(Z_set, [beta_coeff]);
                    \\if(Z_set == Mat(), Z_set = Mat(beta_coeff),Z_set = matconcat([Z_set, beta_coeff]));

			);
		);

		return(Z_set);
}

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
\\ This function is just cubescan, except it allows for some error to include any elements that lie on the boundary cvec
\\ INPUT:
\\ - idealmat is a matrix representing an ideal
\\ - cvec is a boundary vector for the cube
\\ - G is the number field, eps is the error
\\ OUTPUT:
\\ - Set of elements of idealmat whose valuation vector lies in the cube cvec (boundary included)

cubescan_equal(idealmat, cvec, G, eps)={
	my(cvec1);
	cvec1 = vector(length(cvec), i, cvec[i]+eps);
	return(cubescan(idealmat, cvec1, G));
}

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
\\ This function is just cubescan, except it allows for some error to exclude any elements that lie on the boundary cvec
\\ INPUT:
\\ - idealmat is a matrix representing an ideal
\\ - cvec is a boundary vector for the cube
\\ - G is the number field, eps is the error
\\ OUTPUT:
\\ - Set of elements of idealmat whose valuation vector lies in the cube cvec interior

cubescan_unequal(idealmat, cvec, G, eps)={
	my(cvec1);
	cvec1 = vector(length(cvec), i, cvec[i]-eps);
	return(cubescan(idealmat, cvec1, G));
}

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
\\ This function will take in a column vector which represent coefficients wrt the integral basis and check if it is a minimum in the given ideal
\\ Uses cubescan to verify that the normed body is empty
\\ INPUT:
\\ - idealmat is a matrix representing an ideal
\\ - v is the column vector of an element
\\ - G is the number field
\\ - eps is an error
\\ OUTPUT:
\\ - 0 or 1 depending on whether v is a minimum of idealmat

is_minimum(idealmat, v, G, eps)={
    my(normedbody);
    normedbody = cubescan_unequal(idealmat, valuationvec(G,v, column = 1), G, eps);
    if (length(normedbody)!=0 && length(normedbody)!=1, \\sometimes accidentally captures itself
        print(normedbody);
        return(0),
        return(1));
};

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
\\ This function will take in a column vector which represent coefficients wrt the integral basis and check if it is a minimum in the given ideal
\\ Uses cubescan to verify that the normed body is empty
\\ INPUT:
\\ - idealmat is a matrix representing an ideal I
\\ - v is the column vector of an element of G wrt zk
\\ - G is the number field
\\ - eps is an error
\\ OUTPUT:
\\ - 0 or 1 depending on whether v is a minimum of idealmat

is_minimum_alternate(idealmat, v, G, eps)={
    my(normedbody, I_v);
    normI_deltaK = ceil(((2/Pi)^(G.r2))*abs(G.disc)^(1/2)*idealnorm(G,y));
    v_norm = abs(nfeltnorm(G,vecholder ));
    if(v_norm < 1 || v_norm > normI_deltaK , return(0));

    I_v=idealdiv(G,idealmat,v);
    real_Iv = embed_real(G, G[5][1]*I_v);
    LLLchange = qflll(real_Iv);
    I_v_LLL = real_Iv*LLLchange;
    if(norml2(I_v_LLL[,1]) < 1, return(0));
    if(checkred_old(I_v*LLLchange,G, eps ),return(1), return(0) );
};

\\ This function will take in a column vector which represent coefficients wrt the integral basis and check if it is a minima in the given ideal
\\ Uses cubescan to verify that the normed body is empty
\\ INPUT:
\\ - idealmat is a matrix representing an ideal
\\ - v1,v2 are the column vectors of elements
\\ - G is the number field
\\ - eps is an error
\\ OUTPUT:
\\ - 0 or 1 depending on whether v1 and v2 are neighbors
is_neighbour(idealmat, v1, v2, G, eps)={
    my(val1, val2, thebox, box_elements);
    val1 = valuationvec(G,v1, column = 1);
    val2 = valuationvec(G,v2, column = 1);
    thebox = vector(length(val1), i, max(val1[i], val2[i]));
    box_elements = cubescan_unequal(idealmat, thebox, G, eps);
    if(length(box_elements) == 0, return(1), return(0));

}


\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
\\ This computes the expansion of minset along a chosen axis,
\\ as defined in Buchmann, Juntgen and Pohst
\\ Inputs: idealmat is the coefficient matrix of an ideal,
\\ 				 minset is a 2-vec consisting of a set of nf-elements (as columns) and a boundary vector
\\				 axis indicates the coordinate to expand upon
\\ OUTPUT:
\\ - A minimial set, which is a pair comprised of a Set S of elements (as columns) and its corresponding "boundary" vector

expand_minset(idealmat, minset, G, axis)={
	my(expansion_set=Set(),
		expansion = [],
		nfdegree= length(G.zk),
		denom = 2,
		Cvector = minset[2],                                                    \\ boundary vector of the minset
		found=0,
		tempvec,
        beta,
        min_axis_coord
	);
    Cvector[axis] = 2*(abs(G.disc)^(1/nfdegree));
		if(DEBUG_EXPAND,
				print(" Expand: Input minset: ", precision(minset,10) );
				print(" Expand: boundary: ", precision(Cvector,10));
                print(" Expand: Axis: ", axis);
		);

		while((found == 0)|| (denom==2),
            expansion = cubescan_unequal(idealmat, Cvector, G, eps);
			beta = findbeta(G,expansion, Cvector, axis);
			if(beta != 0,
				found = 1;
				tempvec = valuationvec(G,beta);
				Cvector[axis] = tempvec[axis]/denom;
			,\\else
				if(!found,
					Cvector[axis] = 2*Cvector[axis];,
				\\else
					if(denom == 2,
							denom = 1;
							Cvector[axis] = 2*Cvector[axis];
					);
				);
			);
		);
		expansion = cubescan_unequal(idealmat, Cvector, G, eps);						\\ get elements in the interior of the box Cvector

		if(DEBUG_EXPAND,
			print(" Expand: After loop Cvector: ", precision(Cvector,10), "\n Expand: Found elements: ", expansion);
		);

		for(i=1, length(expansion),
                min_axis_coord = valuationvec(G, expansion[i]);
                \\print(i, " ", precision(abs(G[5][1]*expansion[i]),10), "  " , precision(valuationvec(G, expansion[i]),10) );
				if(min_axis_coord[axis] < Cvector[axis], Cvector[axis] = min_axis_coord[axis]);		\\ identifies the one with the smallest valuation on axis-coordinate
		);

		\\ Now scan cube with boundaries included.
		expansion = cubescan_equal(idealmat, Cvector, G,eps);

        for(i=1, length(expansion), expansion_set = setunion(expansion_set, [ vec_flip_positive(expansion[i]) ] ));     \\ This is our Set of minimal elements as column vectors
		if(DEBUG_EXPAND,
		      print(" expansion_set elements: \n--", expansion_set);
		      for(i=1, length(expansion_set), print("--", precision(valuationvec(G,nfbasistoalg(G,expansion_set[i])),10))); print("\n");
		);
		return([expansion_set, Cvector]);
}

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
\\ This is the compression algorithm, 2.3
\\ Computes the compression of a minimal set along an axis.
\\ INPUT:
\\ - minset consists of a Set of column vectors corresponding to elements wrt the integral basis, and a boundary vector
\\ - axis is an integer denoting the direction along which to compress
\\ - G is a number field
\\ OUTPUT:
\\ - A minimal set as above, which is the compression of minset along axis.
compress_minset(minset, axis, G,eps)={
		my(k_S=Set(),                                                           \\ holds the compressed set
        valvec,
        newcoord = 0,
        new_boundary = vector(length(minset[2]), i, 0);
        );

		for(i =1, length(minset[1]),										    \\ for each alpha in S
			valvec = valuationvec(G, minset[1][i], column =1 );				    \\ get the valuation vector for the ith element of minset
			if(valvec[axis] < minset[2][axis]-eps,					            \\ check if the axis component of current element is smaller than the axis boundary coordinate
                k_S = setunion(k_S, [minset[1][i]]);
                for(j=1, length(minset[2]),
                    if(valvec[j] > new_boundary[j], new_boundary[j] = valvec[j]);
                );
			);
		);
		return([k_S, new_boundary]);
}

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
\\ check whether the input Set contains the element 1. This is a subroutine of Alg 2.2, see compute_one_neighbours
\\ The list el_list are the elements of a minimal set, in polynomial form.
check_minset_1(G,el_list)={
    if(length(el_list) == 0, return(0));
    return(setsearch(el_list, nfalgtobasis(G,1))|| setsearch(el_list, 1) );
}

\\ INPUTS:
\\ - G a number field,
\\ - new_minset is a potentially new minimal set, which is a list containing a set of elements along with the real boundary vector
\\ - minset_list which is a List of known minimal sets
include_new_minset(G, new_minset, minset_list, minset_set)={
    if(check_minset_1(G,new_minset[1]) == 1 && setsearch(minset_set, new_minset[1]) == 0,
        minset_list = concat(minset_list, new_minset);
        minset_set  = setunion(minset_set, [new_minset[1]]);
    );
    return([minset_list, minset_set]);
}
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
\\ compute minimal sets containing 1. This is algorithm 2.2 of Practical Lagrange (BJP)
\\ The initialization of variable S assumes that idealmat is a reduced ideal.
\\ Make sure that this is a valid assumption in your use cases.
\\ again recall that a minimal set should be pair (a list of elements, boundary vector)

\\ INPUT:
\\ - G is a number field
\\ - idealmat is the coefficient matrix of a reduced ideal.
\\ - p_avoid is an optional integer that triggers a check on each new minima beta if they are suitable for use in the CPCT REP function
\\   That is, checks if the ideal obtained from division by beta has a denominator coprime to p_avoid
\\ - the variable target is the logarithm embedding of a specific element we are looking for. The algorithm stops and returns the element
\\   if such an element is found.
\\ OUTPUT:
\\ - A set of neighbours of 1

compute_one_neighbours(G, idealmat, eps, p_avoid=1, target = 0)={
	my(S, S1,
        minset_list = List(),
        known_minsets = Set(),
        found_minima_set,
        signaturesum = G.r1 + G.r2,
        vec1= vector(length(G.zk), i, if(i==1, 1, 0))~,
        tempset, mincounter);

	\\ we always start with the minimal set contained in the unit cube.
    \\ This set technically contains all roots of unity, but only 1 is placed here for now
	S = [ Set([vec1]), valuationvec(G,1)];
	minset_list = concat(minset_list, S);										      \\ Perhaps use hash table at some point. See Pari's Map object
    known_minsets = setunion(known_minsets, [S[1]]);
    found_minima_set = Set([S[1][1]]);

	\\ At this point, minset_list just contains the minimal set [1]

    while(length(minset_list) > 0,

        if(DEBUG_MINIMALSET ,
            \\print("  remaining minsets: ", length(minset_list));
            write( "LOG", "  remaining minsets: ", length(minset_list));
        );
		for(i=1, signaturesum,
            \\for(j=1, length(minset_list), print(precision(minset_list[j],10)));


            S= compress_minset(minset_list[1], i, G,eps);
			[minset_list, known_minsets]=include_new_minset(G, S, minset_list, known_minsets);

            S = expand_minset(idealmat, minset_list[1], G, i );

            [minset_list, known_minsets]=include_new_minset(G, S, minset_list, known_minsets);
            mincounter = length(found_minima_set);
            found_minima_set = setunion(found_minima_set, S[1]);


            \\ SPECIAL INSTRUCTIONS for when p_avoid !=1
            if(p_avoid!=1 && length(found_minima_set) > mincounter,
                for(t = 1, length(S[1]),
                    id = idealdiv(G, idealmat, S[1][t]);
                    if(gcd(get_ideal_denom(id), p_avoid)==1,
                        return(S[1]);
                    );
                );
            );
            if(target!= 0 && length(found_minima_set) > mincounter,
                for(t=1, length(S[1]),
                    if(samevecs(target, log(abs(nfeltembed(G,S[1][t])))[1..G.r1+G.r2-1],eps),
                        print("ONE NEIGHBORS: TARGET FOUND");
                        return(S[1]);
                    );
                );
            );

	    ); \\#close the for loop
        minset_list = minset_list[^1];
	); \\ #close the while loop

    found_minima_set = setminus(found_minima_set, Set(0));
    if(DEBUG_MINIMALSET,
	print("ONENEIGHBOUR: no. of minima found: ", length(found_minima_set), ". Distinct Minimal sets: ", length(known_minsets));
    );
    if(DEBUG_MINIMALSET,
        \\listsort(minset_list); for(j=1, length(minset_list), print(j, "  ", minset_list[j]));
        for(j=1, length(found_minima_set),print( j,"  ", nfalgtobasis(G, found_minima_set[j]), "  ",precision(log(abs(nfeltembed(G,found_minima_set[j]))),10)  ););
    );

    return(found_minima_set);
}


\\ INPUT:
\\ - G a number field from nfinit
\\ - idealmat, a coefficient matrix for a REDUCED ideal J of OK.
\\ - minima1 is a minima of the ideal J, as a coefficient vector.
\\ - p_avoid detects for neighbours alpha such that the ideal J/alpha has coprime denominator.
\\   The default value 1 indicates not to do this.
\\ - target is the logarithm embedding of a specific element we are looking for. If such an element is found, the algorithm stops and set containing such an element
\\ OUTPUT:
\\ - the set of neighbours of the minima in the ideal J
NEIGHBORS(G, idealmat, minima1, eps, p_avoid =1,target = 0)={
    my(neighborlist, newlist, D, adjusted_targ=0);

    D = idealdiv(G, idealmat, minima1); D=idealhnf(G,D);
    if(target != 0, adjusted_targ = target - log(abs(nfeltembed(G, minima1)))[1..G.r1+G.r2-1] );
    neighborlist = compute_one_neighbours(G, D, eps, p_avoid, adjusted_targ);
    newlist = vector(length(neighborlist), i , vec_flip_positive(nfalgtobasis(G, nfeltmul(G, minima1, neighborlist[i]))) );
    newlist = Set(newlist);
    return(newlist);
}

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
\\ COLLECT AND ITS MAJOR SUBALGORITHMS
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

\\ Subalgorithm of COLLECT. Adjust the boundary of the COLLECT by our error value
\\ the variable sphere indicates whether our region is a sphere or a box.
compute_collect_boundary(boundary, sphere, eps)={
    my(boundary_eps);
    if(sphere == 1, boundary_eps = (boundary + eps)^2;,
    \\else
        boundary_eps = vector(length(boundary), i, boundary[i]+eps);
    );
    return(boundary_eps);
}

\\ Subalgorithm of COLLECT, add to the collection of minima depending on the search area
\\ - minima_set the set of minima collected so far
\\ - check_element is a potentially new minima contained in the region
\\ - boundary is the boundary of the search region, either a vector or a real value based on the type of region
\\ - region_type = 0 indicates the region is a box, region_type= 1 indicates the region is a sphere
increase_collection(G, minima_set,check_element, boundary, region_type, adjusted_log = 0)={
    my(valuation_vec = valuationvec(G, check_element, column =1));
    if(region_type == 1,
        return( setsearch(minima_set, check_element) == 0 && norml2(valuation_vec) < boundary);
    , region_type == 2,  \\ else if
        valuation_vec = log((valuation_vec))[1..length(adjusted_log)] + adjusted_log;
        return(setsearch(minima_set, check_element) == 0 && is_in_axis_box(valuation_vec, boundary));
    ,\\else
        return( setsearch(minima_set, check_element) == 0 && vec_less_than(valuation_vec, boundary));
    );
}

\\ Method for finding the set of all minima of J contained within the cube defined by Bvec, centered at the origin
\\ INPUT:
\\ - G a number field from nfinit
\\ - idealmat, a coefficient matrix for a REDUCED ideal J of OK.
\\ - Bvec a vector of positive rational numbers, whose length is r1+r2 (number of real plus conjugate pair embeddings)
\\ - eps is some error for the search cube defined by Bvec
\\ - sphere = 1 changes the scan area to a ball otherwise it is a cube.
\\ - target is the length r1+r2-1 log embedding vector of an element we are searching for, no squaring on the complex parts.
\\   The algorithm will stop and return a set containing this element if one is found.
\\ OUTPUT:
\\ - the set of minima in the ideal J which lie in the box defined by Bvec
COLLECT(G, idealmat, Bvec, eps, sphere = 0, target = 0)={

    my( Bvec_error,
        onevec=nfalgtobasis(G, 1),
        minima_collection = Set(),                                              \\ hold all minima in the cube defined by Bvec
        unchecked_min_list = [],
        neighbor_set,
        valuation_holder
    );

    print("COLLECT: Computing neighbours of 1:");
    Bvec_error = compute_collect_boundary(Bvec, sphere, eps);
    neighbor_set = NEIGHBORS(G, idealmat, onevec, eps, 1, target);              \\ gets neighbors of 1, as a set

    \\ HANDLE THE ELEMENT 1
    if(increase_collection(G, minima_collection, onevec, Bvec_error, sphere);,
        minima_collection = setunion(minima_collection, Set([onevec]));
        unchecked_min_list = concat(unchecked_min_list, [onevec]);
    );
    if(length(minima_collection) == 1, unchecked_min_list = unchecked_min_list[^1]);
    for(i=1, length(neighbor_set),
        if(increase_collection(G, minima_collection, neighbor_set[i], Bvec_error, sphere);,
            minima_collection = setunion(minima_collection, Set([neighbor_set[i]]));
            unchecked_min_list = concat(unchecked_min_list, [neighbor_set[i]]);
        );
    );

    while(length(unchecked_min_list) != 0,
        if(DEBUG_COLLECT,  print("-- COLLECT: remaining minima ", length(M), "\nCOLLECT1: ", minima_collection, "\nCOLLECT2: ", unchecked_min_list); );

        neighbor_set = NEIGHBORS(G, idealmat, unchecked_min_list[1], eps, 1, target);
        if(DEBUG_COLLECT,  print("-- COLLECT: Elements in neighbor_set: ", length(neighbor_set); ); );

        for(i=1, length(neighbor_set),
            if(increase_collection(G, minima_collection, neighbor_set[i], Bvec_error, sphere);,
                minima_collection = setunion(minima_collection, Set([neighbor_set[i]]));
                unchecked_min_list = concat(unchecked_min_list, [neighbor_set[i]]);
            );
        );
        unchecked_min_list = unchecked_min_list[^1];
    );
    return(minima_collection);
}

\\ Method for finding the set of all minima of J contained within the axis_aligned_box
\\ INPUT:
\\ - G a number field from nfinit
\\ - idealmat, a coefficient matrix for a REDUCED ideal J of OK.
\\ - logvec_minimum a vector of positive rational numbers, whose length is r+s (no of real plus conjugate pair embeddings)
\\      corresponding to the element mu such that J = (1/mu)O_K
\\ - eps is some error for the search box
\\ OUTPUT:
\\ - the set of minima in the ideal J which lie in the box defined by axis_aligned_box
COLLECT_BABYSTOCK(G, idealmat, logvec_minimum,axis_aligned_box, eps)={

    my(
        onevec=nfalgtobasis(G, 1),
        minima_collection = Set(),                                              \\ hold all minima in the cube defined by Bvec
        unchecked_min_list = [],
        M= List();,                                                             \\ M will hold all minima in the cube defined by Bvec
        Mset,
        neighbor_set,
        valuation_holder,
        m_ctr= 1);
    print("CB: Computing neighbours of 1 for babystock, " , precision(logvec_minimum,10));
    neighbor_set = NEIGHBORS(G, idealmat, onevec, eps);                              \\ gets neighbors of 1, as a set

    \\ Handle the element corresponding to one in the ideal, which has logarithmic embedding logvec_minimum
    if(increase_collection(G, minima_collection, onevec, axis_aligned_box, sphere = 2, adjusted_log = logvec_minimum),
        minima_collection = setunion(minima_collection, Set([onevec]));
        unchecked_min_list = concat(unchecked_min_list, [onevec]);
    );
    if(length(minima_collection) == 1, unchecked_min_list = unchecked_min_list[^1]);

    for(i=1, length(neighbor_set),
        if(increase_collection(G, minima_collection, neighbor_set[i], axis_aligned_box, 2, logvec_minimum);,
            minima_collection = setunion(minima_collection, Set([neighbor_set[i]]));
            unchecked_min_list = concat(unchecked_min_list, [neighbor_set[i]]);
        );
    );
    \\ Looping through elements of M, we need to compute the neighbours of each element
    while( length(unchecked_min_list)!= 0,

        if(DEBUG_COLLECT,  print("-- COLLECT: Unchecked minima: ", length(unchecked_min_list)); );
        neighbor_set = NEIGHBORS(G, idealmat, unchecked_min_list[1], eps);

        if(DEBUG_COLLECT,  print("-- COLLECT: Elements in neighbor_set: ", length(neighbor_set); ); );

        \\ check which neighbours are in the cube, and not already in Mset, add such neighbors to M and Mset
        for(i=1, length(neighbor_set),
            \\print("prior to test: ", idealdiv(G, idealmat, neighbor_set[i]));
            if(increase_collection(G, minima_collection, neighbor_set[i], axis_aligned_box, 2, logvec_minimum);,
                minima_collection = setunion(minima_collection, Set([neighbor_set[i]]));
                unchecked_min_list = concat(unchecked_min_list, [neighbor_set[i]]);
            );
        );
        unchecked_min_list = unchecked_min_list[^1];
    );
    my(hashmap= Map(), Mset2=[]);

    for(i=1, length(minima_collection),
        entry_i = [idealdiv(G, idealmat, minima_collection[i]), log(valuationvec(G, minima_collection[i], column =1 ))[1..length(logvec_minimum)] +logvec_minimum];
        Mset2 = concat(Mset2, [entry_i]);

    );

    for(i=1, length(Mset2),
        print(precision(Mset2[i],10));
    );
    return(Mset2);

}
